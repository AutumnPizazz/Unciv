# 多人同文明功能开发进度

## 功能概述

**目标**：在多人游戏中支持多个玩家选择同一个文明（例如4个玩家都玩埃及）

**注意**：此功能与热座模式不同，是真正的多人游戏场景

**Issue链接**：#13723

## 当前状态

- **状态**：重构阶段（技术准备）
- **开发者**：AutumnPizazz（计划实现）
- **优先级**：中等（已标记为 wontfix，但开发者有兴趣实现）

## 技术背景

### 原有设计问题

当前代码库中，`civName` 被用作文明的唯一标识符，用于：
- 外交关系识别
- 单位归属判断
- 地块所有权
- 序列化/反序列化

这种设计使得在同一游戏中存在多个相同文明成为不可能。

### 重构目标

将文明标识符分离为三个独立的用途：
1. **civID**：技术标识符，用于序列化和查找（唯一）
2. **nationName**：国家名称，对应规则集中的 Nation
3. **displayName**：显示名称（未来功能，允许玩家自定义）

## 已完成的重构工作

### 第一阶段：#14149 & #14228 - 减少对 civName 的依赖

**时间**：2025年11月

**主要变更**：
- 将直接使用 `civName` 的代码改为缓存 `Civilization` 对象
- 减少不必要的 ruleset 和 gameInfo 查找
- 优化性能，避免重复的 map 查找

**关键改动文件**：
- `core/src/com/unciv/logic/civilization/Civilization.kt`
- `core/src/com/unciv/logic/civilization/transients/CivInfoTransientCache.kt`
- `core/src/com/unciv/logic/city/City.kt`
- `core/src/com/unciv/logic/civilization/diplomacy/DiplomacyManager.kt`
- 其他约50个文件

**新增缓存属性**：
- `otherCiv`：外交关系中的对方文明
- `allyCiv`：盟友文明
- `foundingCivObject`：城市建立者文明
- `winningCivObject`：获胜文明

**技术决策**：
- 使用属性而非函数（尽管有争议）
- 保持序列化字段私有
- 正确处理克隆情况（不在克隆中保存缓存）

### 第二阶段：#14334 - 引入 civID

**时间**：2025年12月

**主要变更**：
- 创建新的 `civID` 字段作为真正的唯一标识符
- 保留 `civName` 用于UI显示和国家名称
- 缓存国家数据在文明对象中

**关键改动**：
- 添加 `civID` 字段到 `Civilization` 类
- 更新所有使用 `civName` 作为标识符的代码，改为使用 `civID`
- 约1/3的 `civName` 使用被转换为 `civID`
- 保持向后兼容性

**技术细节**：
- `civID` 用于：序列化、查找、标识符比较
- `civName` 用于：UI显示、通知文本
- 在构造函数中预先缓存国家数据

## 待完成的工作

### 短期任务

1. **完全分离 civName 的用途**
   - 将剩余的 `civName` 使用分类处理
   - 区分技术标识符和显示名称

2. **引入 displayName 字段**
   - 允许玩家自定义文明显示名称
   - 支持多人同文明时区分不同玩家

3. **更新游戏启动逻辑**
   - `GameStarter.addCivilizations` 需要支持重复国家
   - 处理自定义地图和场景加载

4. **UI 更新**
   - 更新所有显示文明名称的地方
   - 确保外交界面正确显示多个相同文明
   - 处理 `PopupAlert` 中 civName/civID 的混淆问题

5. **向后兼容性**
   - 确保旧存档能正常加载
   - 处理新存档在旧版本中的兼容性

### 长期任务

1. **玩家数据重构**
   - `player.choosenCiv` 应该追踪 civID 而非 civName
   - 处理 `TileMap.stripPlayer`（如果使用）

2. **测试覆盖**
   - 添加多人同文明的测试用例
   - 测试序列化/反序列化
   - 测试克隆功能

3. **文档更新**
   - 更新开发者文档
   - 更新 Modding 文档（如果相关）

## 技术挑战与解决方案

### 挑战1：属性 vs 函数

**问题**：是否应该用属性还是函数来设置缓存值

**讨论**：
- yairm210 倾向于使用函数，因为属性可能隐藏副作用
- SeventhM 认为对于这种简单缓存，属性更符合 Kotlin 惯用法

**解决方案**：
- 使用属性，但保持序列化字段私有
- 添加适当的 KDoc 文档
- 避免在属性设置器中执行复杂逻辑

### 挑战2：克隆问题

**问题**：克隆游戏状态时需要正确处理缓存

**解决方案**：
- 不在克隆中保存缓存
- 确保深克隆相关对象
- 在反序列化时正确初始化缓存

### 挑战3：相等性比较

**问题**：`civ.civName == other.civName` 不等同于 `civ == other`

**解决方案**：
- 在正常游戏运行中，可以假设对象引用相等
- 在初始化期间避免使用对象相等性
- 使用 `civID` 进行真正的相等性比较

### 挑战4：性能优化

**问题**：频繁的 HashMap 查找可能影响性能

**解决方案**：
- 缓存频繁使用的对象
- 避免不必要的查找
- 使用 EnumMap 替代 HashMap（在适用时）

## 相关代码文件

### 核心文件

- `core/src/com/unciv/logic/civilization/Civilization.kt` - 文明核心类
- `core/src/com/unciv/logic/civilization/transients/CivInfoTransientCache.kt` - 缓存管理
- `core/src/com/unciv/logic/GameInfo.kt` - 游戏信息
- `core/src/com/unciv/logic/MultiFilter.kt` - 过滤器逻辑

### 外交相关

- `core/src/com/unciv/logic/civilization/diplomacy/DiplomacyManager.kt`
- `core/src/com/unciv/logic/civilization/diplomacy/CityStateFunctions.kt`

### 序列化相关

- `core/src/com/unciv/UncivJson.kt`
- `buildSrc/src/com/unciv/build/SerializationConfig.kt`

## 参考资料

- Issue #13723: Feature request: Multiplayer Same-Civ Play
- PR #14149: Refactor: Prefer cached Civ information over civ names
- PR #14228: Refactor: Prefer cached Civ information over civ names (retry)
- PR #14334: Refactor: Move civ json key to a new variable
- PR #14227: Deep cloning (依赖项)

## 开发者备注

- 当前重构为后续功能实现奠定了基础
- 需要谨慎处理向后兼容性
- 建议分步骤实现，每步充分测试
- 某些代码仍然混合了 civName 和 civID 的用途，需要进一步清理

## 下一步行动

1. 评估当前代码中 civName 的所有使用
2. 制定详细的实现计划
3. 开始实现 displayName 支持
4. 更新相关 UI 组件
5. 添加完整的测试覆盖